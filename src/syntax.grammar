@precedence {
  fncallargs @right
  statement @right
  curlyRight @right
  curlyLeft @left
  assign @right
  primary
  or @left
  and @left
  compare @left
  bitwise @left
  bitShift @left
  add @left
  multiply @left
  prefix

  else @right

  containerDecl @left

  // Prevent SR due to eg: a[0..break label:]
  colonSlice
  colonLabel
}

//// Templates.

list<x> { (x ",")* x? }

//// Root.

@top Program { ContainerDocComment? containerMembers }

containerMembers { !containerDecl (ContainerField ",")* (ContainerField | containerDecl*) }

containerDecl { TestDecl | ComptimeDecl | DocComment? Pub? Decl }

//// Top level.

ContainerDocComment { containerComment+ }

TestDecl { Test TestName Block }

TestName { stringLiteralSingle | identifier }

ComptimeDecl { Comptime Block }

Decl { ( FnProto (";" | Block) | VarDecl ) }

FnProto { fn Identifier? "(" ParamDeclList ")" "!"? TypeExpr }

VarDecl { ( Const | Var ) Name (":" TypeExpr)? ("=" Expr)? ";" }

ContainerField {
  DocComment? Comptime? /*!KEYWORD_fn*/ (Identifier ":")? TypeExpr ByteAlign? ("=" Expr)?
}

Name { identifier }

//// Block level.

Statement {
  (Comptime? VarDecl)
  //| Comptime BlockExprStatement
  | !statement Nosuspend BlockExprStatement
  | Suspend BlockExprStatement
  | Defer BlockExprStatement
  | Errdefer Payload? BlockExprStatement
  | IfStatement
  | !curlyRight labeledStatement
  | !curlyRight SwitchExpr
  | (assignExprExclIf | exprExclIf) ";"
}

IfStatement {
  IfPrefix ( blockExpr (!else Else Payload? Statement)?
             | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

labeledStatement { !curlyRight (Block | LoopStatement) }

LoopStatement { Inline? (ForStatement | WhileStatement) }

ForStatement {
  ForPrefix ( blockExpr (!else Else Statement)?
              | (AssignExpr | Expr) (";" | !else Else Statement) )
}

WhileStatement {
  WhilePrefix ( blockExpr (!else Else Payload? Statement)?
                | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

BlockExprStatement { blockExpr | (AssignExpr | Expr) ";" }

blockExpr { !curlyRight BlockLabel? !curlyRight Block }

//// Expression level.

assignExprExclIf { exprExclIf !assign AssignOp Expr }

AssignExpr { Expr !assign AssignOp Expr }

exprExclIf { binaryExprExclIf | PrefixExpr | !primary primaryExprExclIf }

Expr { BinaryExpr | PrefixExpr | !primary PrimaryExpr }

binaryExprExclIf {
  exprExclIf !or Or Expr
  | exprExclIf !and And Expr
  | exprExclIf !compare CompareOp Expr
  | exprExclIf !bitwise BitwiseOp Expr
  | exprExclIf !bitShift BitShiftOp Expr
  | exprExclIf !add AdditionOp Expr
  | exprExclIf !multiply MultiplyOp Expr
}

BinaryExpr {
  Expr !or Or Expr
  | Expr !and And Expr
  | Expr !compare CompareOp Expr
  | Expr !bitwise BitwiseOp Expr
  | Expr !bitShift BitShiftOp Expr
  | Expr !add AdditionOp Expr
  | Expr !multiply MultiplyOp Expr
}

PrefixExpr { !prefix PrefixOp+ !primary PrimaryExpr }

PrimaryExpr {
  IfExpr
  | BlockLabel? LoopExpr
  | !primary primaryExprExclIf
}

primaryExprExclIf {
  AsmExpr
  | Break BreakLabel? Expr?
  | Comptime Expr
  | !primary Nosuspend Expr
  | Continue BreakLabel?
  | Resume Expr
  | Return Expr?
  | Block
  | curlySuffixExpr
}

curlySuffixExpr { !curlyRight TypeExpr (!curlyRight InitList)? }

InitList {
  "{" FieldInit ("," FieldInit)* ","? "}"
  | "{" Expr ("," Expr)* ","? "}"
  | "{" "}"
}

IfExpr { IfPrefix Expr (!else Else Payload? Expr)? }

Block { "{" Statement* "}" }

LoopExpr {
  // this is for the Inline in SwitchProng
  !curlyRight (Inline (ForExpr | WhileExpr))
  | Inline? (ForExpr | WhileExpr) }

ForExpr { ForPrefix Expr (!else Else Expr)? }

WhileExpr { WhilePrefix Expr (!else Else Payload? Expr)? }

TypeExpr { PrefixTypeOp* (ErrorUnionExpr | suffixExpr) }

ErrorUnionExpr { suffixExpr !curlyRight "!" TypeExpr }

suffixExpr {
  Async primaryTypeExpr SuffixOp* FnCallArgs
  | !assign primaryTypeExpr (SuffixOp | FnCallArgs)*
}

primaryTypeExpr {
  BuiltinIdentifier FnCallArgs
  | CharLiteral
  | ContainerDecl
  | "." Identifier
  | "." InitList
  | ErrorSetDecl
  | Float
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | Identifier
  | IfTypeExpr
  | Integer
  //| Comptime TypeExpr
  | Error "." Identifier
  | Anyframe
  | Unreachable
  | StringLiteral
  | SwitchExpr
}

ContainerDecl { ( Extern | Packed )? ContainerDeclAuto }

ErrorSetDecl { Error "{" list<DocComment? Identifier> "}" }

GroupedExpr { "(" Expr ")" }

IfTypeExpr { IfPrefix TypeExpr (!else Else Payload? TypeExpr)? }

LabeledTypeExpr { BlockLabel Block | BlockLabel? LoopTypeExpr }

LoopTypeExpr {
  // this is for the Inline in SwitchProng
  !curlyRight (Inline (ForTypeExpr | WhileTypeExpr))
  | Inline? (ForTypeExpr | WhileTypeExpr)
}

ForTypeExpr { ForPrefix TypeExpr (!else Else TypeExpr)? }

WhileTypeExpr { WhilePrefix TypeExpr (!else Else Payload? TypeExpr)? }

SwitchExpr { Switch "(" Expr ")" "{" list<SwitchProng> "}" }

//// Assembly.

AsmExpr { Asm Volatile? "(" Expr AsmOutput? ")" }

AsmOutput { ":" list<AsmOutputItem> AsmInput? }

AsmOutputItem { "[" Identifier "]" StringLiteral "(" (("->" TypeExpr) | Identifier) ")" }

AsmInput { ":" list<AsmInputItem> AsmClobbers? }

AsmInputItem { "[" Identifier "]" StringLiteral "(" Expr ")" }

AsmClobbers { ":" list<StringLiteral> }

//// Helper grammar.

BreakLabel { !colonLabel ":" Identifier }

BlockLabel { /*left*/ Identifier !colonLabel ":" }

FieldInit { "." Identifier "=" Expr }

WhileContinueExpr { ":" "(" (AssignExpr | Expr) ")" }

AddrSpace { TokAddrSpace "(" Expr ")" }

//// Fn specific.

ParamDeclList { list<ParamDecl> }

ParamDecl { //seq(optional($.doc_comment), optional(choice("noalias", "comptime")), optional(seq($.identifier, ":")), $.param_type),
            (Identifier ":") ParamType
            | "..." }

ParamType { Anytype | TypeExpr }

//// Control flow prefixes

IfPrefix { If "(" Expr ")" PtrPayload? }

WhilePrefix { While "(" Expr ")" PtrPayload? WhileContinueExpr? }

ForPrefix { For "(" ForArgList ")" PtrListPayload }

//// Payloads

Payload { "|" Identifier "|" }

PtrPayload { "|" Star? Identifier "|" }

PtrIndexPayload { "|" "*"? Identifier ("," Identifier)* "|" }

PtrListPayload { "|" "*"? Identifier ("," "*"? Identifier)* ","? "|" }

Star { "*" }

//// Switch specific.

SwitchProng { Inline? SwitchCase "=>" PtrIndexPayload? (AssignExpr | Expr) }

SwitchCase { SwitchItem ("," SwitchItem)* ","? | Else }

SwitchItem { Expr ("..." Expr)? }

//// For specific.

ForArgList { ForItem ("," ForItem)* ","? }

ForItem { Expr (".." Expr?)? }

//// Operators

CompareOp { "==" | "!=" | ">" | "<" | ">=" | "<=" }

AssignOp { "*=" | "*|=" | "/=" | "%=" | "+=" | "+|=" | "-=" | "-|=" | "<<=" | "<<|=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%=" | "=" }

BitwiseOp { "&" | "^" | "|" | Orelse | Catch Payload? }

BitShiftOp { "<<" | ">>" | "<<|" }

AdditionOp { "+" | "-" | "++" }

MultiplyOp { "||" | "*" | arithOp<"/"> | "%" | "**" | "*%" | "*|" }

PrefixOp { "!" | "-" | "~" | "-%" | "&" | Try | Await }

PrefixTypeOp {
  "?"
  | Anyframe "->"
  | SliceTypeStart (ByteAlign | AddrSpace | Const | Volatile | Allowzero)*
  | PtrTypeStart (AddrSpace | Align "(" Expr (":" Expr ":" Expr)? ")" | Const | Volatile | Allowzero)*
  | ArrayTypeStart
}

ArrayAccess { "[" Expr "]" }
Slice { "[" Expr ".." (Expr? (!colonSlice ":" Expr)?)? "]" }
Deref { ".*" }
Unwrap { ".?" }
FieldAccess { "." Identifier }

SuffixOp { Slice | ArrayAccess | FieldAccess | Deref | Unwrap }

FnCallArgs { !fncallargs "(" list<Expr> ")" }

//// Ptr specific.

SliceTypeStart { "[" (":" Expr)? "]" }

PtrTypeStart {
  "*"
  | "**"
  // "...extended tokens allow both meanings to take effect, implicitly enabling GLR when both apply."
  // vs kw<"c">, which turns any c into a keyword (when they may instead be identifiers)
  | "[" "*" (@extend<identifier, "c"> | ":" Expr)? "]"
}

ArrayTypeStart { "[" Expr (":" Expr)? "]" }

//// ContainerDecl specific.

ContainerDeclAuto { ContainerDeclType "{" ContainerDocComment? containerMembers "}" }

ContainerDeclType {
  Struct ("(" Expr ")")?
  | Opaque
  | Enum ("(" Expr ")")?
  | Union ("(" (Enum ("(" Expr ")")? | Expr) ")")?
}

//// Alignment

Align { align }

ByteAlign { align "(" Expr ")" }

////

Identifier { identifier }

BuiltinIdentifier { builtinIdentifier }

StringLiteral { stringLiteralSingle | multiStringLiteral }

@skip { whitespace | LineComment }

kw<term> { @specialize<identifier, term> }

TokAddrSpace { kw<"addrspace"> }
align { kw<"align"> }
Allowzero { kw<"allowzero"> }
And { kw<"and"> }
Anyframe { kw<"anyframe"> }
Anytype { kw<"anytype"> }
Asm { kw<"asm"> }
Async { kw<"async"> }
Await { kw<"await"> }
Break { kw<"break"> }
Catch { kw<"catch"> }
Comptime { kw<"comptime"> }
Const { kw<"const"> }
Continue { kw<"continue"> }
Defer { kw<"defer"> }
Else { kw<"else"> }
Enum { kw<"enum"> }
Errdefer { kw<"errdefer"> }
Error { kw<"error"> }
Extern { kw<"extern"> }
fn { kw<"fn"> }
For { kw<"for"> }
If { kw<"if"> }
Inline { kw<"inline"> }
Nosuspend { kw<"nosuspend"> }
Opaque { kw<"opaque"> }
Or { kw<"or"> }
Orelse { kw<"orelse"> }
Packed { kw<"packed"> }
Pub { kw<"pub"> }
Resume { kw<"resume"> }
Return { kw<"return"> }
Struct { kw<"struct"> }
Suspend { kw<"suspend"> }
Switch { kw<"switch"> }
Test { kw<"test"> }
Try { kw<"try"> }
Union { kw<"union"> }
Unreachable { kw<"unreachable"> }
Var { kw<"var"> }
Volatile { kw<"volatile"> }
While { kw<"while"> }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\r"? "\n")+
  }

  //identifier: ($) => choice(/[A-Za-z_][A-Za-z0-9_]*/, seq("@", $.string_literal)),
  identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
  }

  builtinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  Integer {
    "0b" $[01] ("_"? $[01])*
    | "0o" $[0-7] ("_"? $[0-7])*
    | "0x" $[0-9a-fA-F] ("_"? $[0-9a-fA-F])*
    | $[0-9] ("_"? $[0-9])*
  }

  numeric_<regex> { regex ("_"? regex)* }

  Float {
    "0x" numeric_<$[0-9a-fA-F]> "." numeric_<$[0-9a-fA-F]> ($[pP] $[+\-]? numeric_<$[0-9]>)?
    | numeric_<$[0-9]> "." numeric_<$[0-9]> ($[eE] $[+\-]? numeric_<$[0-9]>)?
    | "0x" numeric_<$[0-9a-fA-F]> $[pP] "-" numeric_<$[0-9]>
    | numeric_<$[0-9]> $[eE] "-" numeric_<$[0-9]>
  }

  @precedence { Float Integer }

  multiStringLiteral { ("\\\\" ![\n]* $[ \n]*)+ }

  stringEscape {
    "\\n" | "\\r" | "\\t" | "\\\\" | "\\'" | "\\\"" | "\\x" $[0-9a-fA-F] $[0-9a-fA-F]
    | "\\u{" $[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] $[0-9a-fA-F]?)?)?)?)? "}"
  }

  CharLiteral {
    "'"
    ( // charFragment
      !['\\]
      | stringEscape
    )*
    "'"
  }

  stringLiteralSingle {
    "\""
    ( // stringFragment
      !["\\]*
      | stringEscape
    )*
    "\""
  }

  LineComment[isolate] { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  DocComment[isolate] { ("///" (![/\n] ![\n]* $[ \n]*|()))+ }

  containerComment { "//!" ![\n]* $[ \n]* }

  arithOp<expr> { expr }

  @precedence { containerComment, DocComment, LineComment, arithOp }
}

@external propSource highlighting from "./highlight"
