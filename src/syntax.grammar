@precedence {
  or @left
  and @left
  compare @left
  bitwise @left
  bitShift @left
  add @left
  multiply @left

  prefix

  else @right
}

@top Program { ContainerDocComment? containerDecls }

containerDecls { containerDecl* }

containerDecl { TestDecl | /* comptimeDecl |*/ DocComment? Pub? Decl }

//// Top level.

ContainerDocComment { containerComment+ }

TestDecl { Test TestName Block }

TestName { stringLiteralSingle | identifier }

Decl { ( FnProto (";" | Block) | VarDecl ) }

FnProto { fn Identifier? "(" ParamDeclList ")" TypeExpr }

VarDecl { ( Const | Var ) Name (":" TypeExpr)? ("=" Expr)? ";" }

Name { identifier }

//// Block level.

Statement {
  IfStatement
  | labeledStatement
  | (assignExprExclIf | exprExclIf) ";"
}

IfStatement {
  IfPrefix ( blockExpr (!else Else Payload? Statement)?
             | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

labeledStatement { Block | loopStatement }

loopStatement { ForStatement | WhileStatement }

ForStatement {
  ForPrefix ( blockExpr (!else Else Statement)?
              | (AssignExpr | Expr) (";" | !else Else Statement) )
}

WhileStatement {
  WhilePrefix ( blockExpr (!else Else Payload? Statement)?
                | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

blockExpr { Block }

//// Expression level.

assignExprExclIf { exprExclIf AssignOp Expr }

AssignExpr { Expr AssignOp Expr }

exprExclIf { binaryExprExclIf | PrefixExpr | primaryExprExclIf }

Expr { BinaryExpr | PrefixExpr | PrimaryExpr }

binaryExprExclIf {
  exprExclIf !or Or Expr
  | exprExclIf !and And Expr
  | exprExclIf !compare CompareOp Expr
  | exprExclIf !bitwise BitwiseOp Expr
  | exprExclIf !bitShift BitShiftOp Expr
  | exprExclIf !add AdditionOp Expr
  | exprExclIf !multiply MultiplyOp Expr
}

BinaryExpr {
  Expr !or Or Expr
  | Expr !and And Expr
  | Expr !compare CompareOp Expr
  | Expr !bitwise BitwiseOp Expr
  | Expr !bitShift BitShiftOp Expr
  | Expr !add AdditionOp Expr
  | Expr !multiply MultiplyOp Expr
}

PrefixExpr { !prefix PrefixOp+ PrimaryExpr }

PrimaryExpr {
  IfExpr
  | primaryExprExclIf
}

primaryExprExclIf {
  Break
  | Continue
  | Return Expr?
  | CurlySuffixExpr
}

CurlySuffixExpr { TypeExpr }

IfExpr { IfPrefix Expr (!else Else Payload? Expr)? }

Block { "{" Statement* "}" }

TypeExpr { //seq(repeat($.prefix_type_op), choice($.error_union_expr, $._suffix_expr)),
           suffixExpr }

suffixExpr { ( //seq("async", $._primary_type_expr, repeat($._suffix_op), $.fn_call_arguments),
               //seq($._primary_type_expr, repeat(choice($._suffix_op, $.fn_call_arguments))),
               PrimaryTypeExpr (SuffixOp | FnCallArgs)* ) }

PrimaryTypeExpr {
  BuiltinIdentifier FnCallArgs
  | Identifier
  | Integer
  | StringLiteral }

//// Fn specific.

ParamDeclList { (ParamDecl ",")* ParamDecl? }

ParamDecl { //seq(optional($.doc_comment), optional(choice("noalias", "comptime")), optional(seq($.identifier, ":")), $.param_type),
            (Identifier ":") ParamType
            | "..." }

ParamType { anytype | TypeExpr }

//// Control flow prefixes

IfPrefix { If "(" Expr ")" PtrPayload? }

WhilePrefix { While "(" Expr ")" PtrPayload? /* while_continue_expr */}

ForPrefix { For "(" ForArgList ")" PtrListPayload }

//// Payloads

Payload { "|" Identifier "|" }

PtrPayload { "|" Star? Identifier "|" }

PtrListPayload { "|" "*"? Identifier ("," "*"? Identifier)* ","? "|" }

Star { "*" }

//// For specific.

ForArgList { ForItem ("," ForItem)* ","? }

ForItem { Expr (".." Expr?)? }

//// Operators

CompareOp { "==" | "!=" | ">" | "<" | ">=" | "<=" }

AssignOp { "*=" | "*|=" | "/=" | "%=" | "+=" | "+|=" | "-=" | "-|=" | "<<=" | "<<|=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%=" | "=" }

BitwiseOp { "&" | "^" | "|" | Orelse | Catch Payload? }

BitShiftOp { "<<" } //| ">>" | "<<| }

AdditionOp { "+" | "-" | "++" }

MultiplyOp { "||" } // | "*" } // | "/" | "%" | "**" | "*%" | "*|" }

PrefixOp { "!" | "-" | "~" | "-%" | "&" | Try | Await }

ArrayAccess { "[" Expr "]" }
Slice { "[" Expr ".." (Expr (":" Expr)?)? "]" }
Deref { ".*" }
Unwrap { ".?" }
FieldAccess { "." Identifier }

SuffixOp { Slice | ArrayAccess | FieldAccess | Deref | Unwrap }

FnCallArgs { "(" (Expr ",")* Expr? ")" }

////

Identifier { identifier }

BuiltinIdentifier { builtinIdentifier }

StringLiteral { stringLiteralSingle /* | multiStringLiteral */ }

@skip { whitespace | LineComment }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\\" "\r"? "\n")+
  }

  And { "and" }
  Await { "await" }
  anytype { "anytype" }
  Break { "break" }
  Catch { "catch" }
  Const { "const" }
  Continue { "continue" }
  Else { "else" }
  fn { "fn" }
  For { "for" }
  If { "if" }
  Or { "or" }
  Orelse { "orelse" }
  Pub { "pub" }
  Return { "return" }
  Test { "test" }
  Try { "try" }
  Var { "var" }
  While { "while" }

  Integer { $[0-9]+ }

  //identifier: ($) => choice(/[A-Za-z_][A-Za-z0-9_]*/, seq("@", $.string_literal)),
  identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
  }

  builtinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  @precedence { And Await anytype Break Catch Const Continue Else fn For If Integer Or Orelse Pub Return Test Try Var While
                identifier }

  stringLiteralSingle {
    "\""
    ( // stringFragment
      !["\\]*
      // stringEscape
      | ("\\n" | "\\r" | "\\t" | "\\\\" | "\\'" | "\\\"" | "\\x" $[0-9a-fA-F] $[0-9a-fA-F]
         | "\\u{" $[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] $[0-9a-fA-F]?)?)?)?)? "}")
    )*
    "\"" }

  LineComment[isolate] { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  DocComment[isolate] { ("///" (![/\n] ![\n]* $[ \n]*|()))+ }

  containerComment { "//!" ![\n]* $[ \n]* }

  @precedence { containerComment, DocComment, LineComment }
}
