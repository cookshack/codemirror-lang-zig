@precedence {
  fncallargs @right
  statement @right
  curlyRight @right
  curlyLeft @left
  assign @right
  primary
  or @left
  and @left
  compare @left
  bitwise @left
  bitShift @left
  add @left
  multiply @left
  prefix

  else @right

  containerDecl @left

  // Prevent SR due to eg: a[0..break label:]
  colonSlice
  colonLabel
}

//// Templates.

list<x> { (x ",")* x? }

//// Root.

@top Program { ContainerDocComment? containerMembers }

containerMembers { !containerDecl (ContainerField ",")* (ContainerField | containerDecl*) }

containerDecl { TestDecl | ComptimeDecl | DocComment? Pub? Decl }

//// Top level.

ContainerDocComment { containerComment+ }

TestDecl { Test TestName Block }

TestName { stringLiteralSingle | identifier }

ComptimeDecl { Comptime Block }

Decl { ( FnProto (";" | Block) | VarDecl ) }

FnProto { fn Identifier? "(" ParamDeclList ")" "!"? TypeExpr }

VarDecl { ( Const | Var ) Name (":" TypeExpr)? ("=" Expr)? ";" }

ContainerField {
  DocComment? Comptime? /*!KEYWORD_fn*/ (Identifier ":")? TypeExpr ByteAlign? ("=" Expr)?
}

Name { identifier }

//// Block level.

Statement {
  (Comptime? VarDecl)
  //| Comptime BlockExprStatement
  | !statement Nosuspend BlockExprStatement
  | Suspend BlockExprStatement
  | Defer BlockExprStatement
  | Errdefer Payload? BlockExprStatement
  | IfStatement
  | !curlyRight labeledStatement
  | !curlyRight SwitchExpr
  | (assignExprExclIf | exprExclIf) ";"
}

IfStatement {
  IfPrefix ( blockExpr (!else Else Payload? Statement)?
             | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

labeledStatement { !curlyRight (Block | loopStatement) }

loopStatement { ForStatement | WhileStatement }

ForStatement {
  ForPrefix ( blockExpr (!else Else Statement)?
              | (AssignExpr | Expr) (";" | !else Else Statement) )
}

WhileStatement {
  WhilePrefix ( blockExpr (!else Else Payload? Statement)?
                | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

BlockExprStatement { blockExpr | (AssignExpr | Expr) ";" }

blockExpr { !curlyRight BlockLabel? !curlyRight Block }

//// Expression level.

assignExprExclIf { exprExclIf !assign AssignOp Expr }

AssignExpr { Expr !assign AssignOp Expr }

exprExclIf { binaryExprExclIf | PrefixExpr | !primary primaryExprExclIf }

Expr { BinaryExpr | PrefixExpr | !primary PrimaryExpr }

binaryExprExclIf {
  exprExclIf !or Or Expr
  | exprExclIf !and And Expr
  | exprExclIf !compare CompareOp Expr
  | exprExclIf !bitwise BitwiseOp Expr
  | exprExclIf !bitShift BitShiftOp Expr
  | exprExclIf !add AdditionOp Expr
  | exprExclIf !multiply MultiplyOp Expr
}

BinaryExpr {
  Expr !or Or Expr
  | Expr !and And Expr
  | Expr !compare CompareOp Expr
  | Expr !bitwise BitwiseOp Expr
  | Expr !bitShift BitShiftOp Expr
  | Expr !add AdditionOp Expr
  | Expr !multiply MultiplyOp Expr
}

PrefixExpr { !prefix PrefixOp+ !primary PrimaryExpr }

PrimaryExpr {
  IfExpr
  | BlockLabel? LoopExpr
  | !primary primaryExprExclIf
}

primaryExprExclIf {
  AsmExpr
  | Break BreakLabel? Expr?
  | Comptime Expr
  | !primary Nosuspend Expr
  | Continue BreakLabel?
  | Resume Expr
  | Return Expr?
  | Block
  | curlySuffixExpr
}

curlySuffixExpr { !curlyRight TypeExpr (!curlyRight InitList)? }

InitList {
  "{" FieldInit ("," FieldInit)* ","? "}"
  | "{" Expr ("," Expr)* ","? "}"
  | "{" "}"
}

IfExpr { IfPrefix Expr (!else Else Payload? Expr)? }

Block { "{" Statement* "}" }

LoopExpr { /*Inline?*/ ( ForExpr | WhileExpr) }

ForExpr { ForPrefix Expr (!else Else Expr)? }

WhileExpr { WhilePrefix Expr (!else Else Payload? Expr)? }

TypeExpr { PrefixTypeOp* (ErrorUnionExpr | suffixExpr) }

ErrorUnionExpr { suffixExpr !curlyRight "!" TypeExpr }

suffixExpr { Async primaryTypeExpr SuffixOp* FnCallArgs
             | !assign primaryTypeExpr (SuffixOp | FnCallArgs)* }

primaryTypeExpr {
  BuiltinIdentifier FnCallArgs
  | CharLiteral
  | ContainerDecl
  | "." Identifier
  | "." InitList
  | ErrorSetDecl
  | Float
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | Identifier
  | IfTypeExpr
  | Integer
  //| Comptime TypeExpr
  | Error "." Identifier
  | Anyframe
  | Unreachable
  | StringLiteral
  | SwitchExpr }

ContainerDecl { ( Extern | Packed )? ContainerDeclAuto }

ErrorSetDecl { Error "{" list<DocComment? Identifier> "}" }

GroupedExpr { "(" Expr ")" }

IfTypeExpr { IfPrefix TypeExpr (!else Else Payload? TypeExpr)? }

LabeledTypeExpr { BlockLabel Block | BlockLabel? LoopTypeExpr }

LoopTypeExpr { /*Inline?*/ ( ForTypeExpr | WhileTypeExpr) }

ForTypeExpr { ForPrefix TypeExpr (!else Else TypeExpr)? }

WhileTypeExpr { WhilePrefix TypeExpr (!else Else Payload? TypeExpr)? }

SwitchExpr { Switch "(" Expr ")" "{" list<SwitchProng> "}" }

//// Assembly.

AsmExpr { Asm Volatile? "(" Expr AsmOutput? ")" }

AsmOutput { ":" list<AsmOutputItem> AsmInput? }

AsmOutputItem { "[" Identifier "]" StringLiteral "(" (("->" TypeExpr) | Identifier) ")" }

AsmInput { ":" list<AsmInputItem> AsmClobbers? }

AsmInputItem { "[" Identifier "]" StringLiteral "(" Expr ")" }

AsmClobbers { ":" list<StringLiteral> }

//// Helper grammar.

BreakLabel { !colonLabel ":" Identifier }

BlockLabel { /*left*/ Identifier !colonLabel ":" }

FieldInit { "." Identifier "=" Expr }

WhileContinueExpr { ":" "(" (AssignExpr | Expr) ")" }

AddrSpace { TokAddrSpace "(" Expr ")" }

//// Fn specific.

ParamDeclList { list<ParamDecl> }

ParamDecl { //seq(optional($.doc_comment), optional(choice("noalias", "comptime")), optional(seq($.identifier, ":")), $.param_type),
            (Identifier ":") ParamType
            | "..." }

ParamType { Anytype | TypeExpr }

//// Control flow prefixes

IfPrefix { If "(" Expr ")" PtrPayload? }

WhilePrefix { While "(" Expr ")" PtrPayload? WhileContinueExpr? }

ForPrefix { For "(" ForArgList ")" PtrListPayload }

//// Payloads

Payload { "|" Identifier "|" }

PtrPayload { "|" Star? Identifier "|" }

PtrIndexPayload { "|" "*"? Identifier ("," Identifier) "|" }

PtrListPayload { "|" "*"? Identifier ("," "*"? Identifier)* ","? "|" }

Star { "*" }

//// Switch specific.

SwitchProng { /*Inline?*/ SwitchCase "=>" PtrIndexPayload? (AssignExpr | Expr) }

SwitchCase { SwitchItem ("," SwitchItem)* ","? | Else }

SwitchItem { Expr ("..." Expr)? }

//// For specific.

ForArgList { ForItem ("," ForItem)* ","? }

ForItem { Expr (".." Expr?)? }

//// Operators

CompareOp { "==" | "!=" | ">" | "<" | ">=" | "<=" }

AssignOp { "*=" | "*|=" | "/=" | "%=" | "+=" | "+|=" | "-=" | "-|=" | "<<=" | "<<|=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%=" | "=" }

BitwiseOp { "&" | "^" | "|" | Orelse | Catch Payload? }

BitShiftOp { "<<" | ">>" | "<<|" }

AdditionOp { "+" | "-" | "++" }

MultiplyOp { "||" | "*" | arithOp<"/"> | "%" | "**" | "*%" | "*|" }

PrefixOp { "!" | "-" | "~" | "-%" | "&" | Try | Await }

PrefixTypeOp {
  "?"
  | Anyframe "->"
//  | SliceTypeStart (ByteAlign | AddrSpace | Const | Volatile | Allowzero)*
//  | PtrTypeStart (AddrSpace | Align | "(" Expr (":" Expr ":" Expr)? ")" | Const | Volatile | Allowzero)*
//  | ArrayTypeStart
}

ArrayAccess { "[" Expr "]" }
Slice { "[" Expr ".." (Expr? (!colonSlice ":" Expr)?)? "]" }
Deref { ".*" }
Unwrap { ".?" }
FieldAccess { "." Identifier }

SuffixOp { Slice | ArrayAccess | FieldAccess | Deref | Unwrap }

FnCallArgs { !fncallargs "(" list<Expr> ")" }

//// Ptr specific.

SliceTypeStart { "[" (":" Expr)? "]" }

PtrTypeStart {
  "*"
  | "**"
  | "[" "*" (C | ":" Expr)? "]"
}

ArrayTypeStart { "[" Expr (":" Expr)? "]" }

//// ContainerDecl specific.

ContainerDeclAuto { ContainerDeclType "{" ContainerDocComment? containerMembers "}" }

ContainerDeclType {
  Struct ("(" Expr ")")?
  | Opaque
  | Enum ("(" Expr ")")?
  | Union ("(" (Enum ("(" Expr ")")? | Expr) ")")? }

//// Alignment

Align { align }

ByteAlign { align "(" Expr ")" }

////

Identifier { identifier }

BuiltinIdentifier { builtinIdentifier }

StringLiteral { stringLiteralSingle | multiStringLiteral }

@skip { whitespace | LineComment }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\r"? "\n")+
  }

  TokAddrSpace { "addrspace" }
  align { "align" }
  Allowzero { "allowzero" }
  And { "and" }
  Anyframe { "anyframe" }
  Anytype { "anytype" }
  Asm { "asm" }
  Async { "async" }
  Await { "await" }
  Break { "break" }
  C { "c" }
  Catch { "catch" }
  Comptime { "comptime" }
  Const { "const" }
  Continue { "continue" }
  Defer { "defer" }
  Else { "else" }
  Enum { "enum" }
  Errdefer { "errdefer" }
  Error { "error" }
  Extern { "extern" }
  fn { "fn" }
  For { "for" }
  If { "if" }
  Nosuspend { "nosuspend" }
  Opaque { "opaque" }
  Or { "or" }
  Orelse { "orelse" }
  Packed { "packed" }
  Pub { "pub" }
  Resume { "resume" }
  Return { "return" }
  Struct { "struct" }
  Suspend { "suspend" }
  Switch { "switch" }
  Test { "test" }
  Try { "try" }
  Union { "union" }
  Unreachable { "unreachable" }
  Var { "var" }
  Volatile { "volatile" }
  While { "while" }

  //identifier: ($) => choice(/[A-Za-z_][A-Za-z0-9_]*/, seq("@", $.string_literal)),
  identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
  }

  builtinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  @precedence { align Allowzero And Anyframe Anytype Asm Async Await Break C Catch Comptime Const Continue Defer Else Enum Errdefer Error Extern
                fn For If Nosuspend Opaque Or Orelse Packed Pub Resume Return Struct Suspend Switch Test Try Union
                Unreachable Var Volatile While
                identifier }

  Integer {
    "0b" $[01] ("_"? $[01])*
    | "0o" $[0-7] ("_"? $[0-7])*
    | "0x" $[0-9a-fA-F] ("_"? $[0-9a-fA-F])*
    | $[0-9] ("_"? $[0-9])*
  }

  numeric_<regex> { regex ("_"? regex)* }

  Float {
    "0x" numeric_<$[0-9a-fA-F]> "." numeric_<$[0-9a-fA-F]> ($[pP] $[+\-]? numeric_<$[0-9]>)?
    | numeric_<$[0-9]> "." numeric_<$[0-9]> ($[eE] $[+\-]? numeric_<$[0-9]>)?
    | "0x" numeric_<$[0-9a-fA-F]> $[pP] "-" numeric_<$[0-9]>
    | numeric_<$[0-9]> $[eE] "-" numeric_<$[0-9]>
  }

  @precedence { Float Integer }

  multiStringLiteral { ("\\\\" ![\n]* $[ \n]*)+ }

  stringEscape { ("\\n" | "\\r" | "\\t" | "\\\\" | "\\'" | "\\\"" | "\\x" $[0-9a-fA-F] $[0-9a-fA-F]
                  | "\\u{" $[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] $[0-9a-fA-F]?)?)?)?)? "}") }

  CharLiteral {
    "'"
    ( // charFragment
      !['\\]
      | stringEscape
    )*
    "'" }

  stringLiteralSingle {
    "\""
    ( // stringFragment
      !["\\]*
      | stringEscape
    )*
    "\"" }

  LineComment[isolate] { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  DocComment[isolate] { ("///" (![/\n] ![\n]* $[ \n]*|()))+ }

  containerComment { "//!" ![\n]* $[ \n]* }

  arithOp<expr> { expr }

  @precedence { containerComment, DocComment, LineComment, arithOp }
}

@external propSource highlighting from "./highlight"
