@precedence {
  fncallargs @right
  curlyRight @right
  curlyLeft @left
  assign @right
  primary
  or @left
  and @left
  compare @left
  bitwise @left
  bitShift @left
  add @left
  multiply @left
  prefix

  else @right

  containerDecl @left

  // Prevent SR due to eg: a[0..break label:]
  colonSlice
  colonLabel
}

@top Program { ContainerDocComment? containerMembers }

containerMembers { !containerDecl (ContainerField ",")* (ContainerField | containerDecl*) }

containerDecl { TestDecl | ComptimeDecl | DocComment? Pub? Decl }

//// Top level.

ContainerDocComment { containerComment+ }

TestDecl { Test TestName Block }

TestName { stringLiteralSingle | identifier }

ComptimeDecl { Comptime Block }

Decl { ( FnProto (";" | Block) | VarDecl ) }

FnProto { fn Identifier? "(" ParamDeclList ")" "!"? TypeExpr }

VarDecl { ( Const | Var ) Name (":" TypeExpr)? ("=" Expr)? ";" }

ContainerField {
  DocComment? Comptime? /*!KEYWORD_fn*/ (Identifier ":")? TypeExpr ByteAlign? ("=" Expr)?
}

Name { identifier }

//// Block level.

Statement {
  (Comptime? VarDecl)
  | IfStatement
  | !curlyRight labeledStatement
  | !curlyRight SwitchExpr
  | (assignExprExclIf | exprExclIf) ";"
}

IfStatement {
  IfPrefix ( blockExpr (!else Else Payload? Statement)?
             | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

labeledStatement { !curlyRight (Block | loopStatement) }

loopStatement { ForStatement | WhileStatement }

ForStatement {
  ForPrefix ( blockExpr (!else Else Statement)?
              | (AssignExpr | Expr) (";" | !else Else Statement) )
}

WhileStatement {
  WhilePrefix ( blockExpr (!else Else Payload? Statement)?
                | (AssignExpr | Expr) (";" | !else Else Payload? Statement) )
}

blockExpr { !curlyRight BlockLabel? Block }

//// Expression level.

assignExprExclIf { exprExclIf !assign AssignOp Expr }

AssignExpr { Expr !assign AssignOp Expr }

exprExclIf { binaryExprExclIf | PrefixExpr | !primary primaryExprExclIf }

Expr { BinaryExpr | PrefixExpr | !primary PrimaryExpr }

binaryExprExclIf {
  exprExclIf !or Or Expr
  | exprExclIf !and And Expr
  | exprExclIf !compare CompareOp Expr
  | exprExclIf !bitwise BitwiseOp Expr
  | exprExclIf !bitShift BitShiftOp Expr
  | exprExclIf !add AdditionOp Expr
  | exprExclIf !multiply MultiplyOp Expr
}

BinaryExpr {
  Expr !or Or Expr
  | Expr !and And Expr
  | Expr !compare CompareOp Expr
  | Expr !bitwise BitwiseOp Expr
  | Expr !bitShift BitShiftOp Expr
  | Expr !add AdditionOp Expr
  | Expr !multiply MultiplyOp Expr
}

PrefixExpr { !prefix PrefixOp+ !primary PrimaryExpr }

PrimaryExpr { IfExpr | BlockLabel? LoopExpr | !primary primaryExprExclIf }

primaryExprExclIf {
  Break BreakLabel? Expr?
  | Comptime Expr
  | Continue BreakLabel?
  | Return Expr?
  | Block
  | curlySuffixExpr
}

curlySuffixExpr { !curlyRight TypeExpr (!curlyRight InitList)? }

InitList {
  "{" FieldInit ("," FieldInit)* ","? "}"
  | "{" Expr ("," Expr)* ","? "}"
  | "{" "}"
}

IfExpr { IfPrefix Expr (!else Else Payload? Expr)? }

Block { "{" Statement* "}" }

LoopExpr { /*Inline?*/ ( ForExpr | WhileExpr) }

ForExpr { ForPrefix Expr (!else Else Expr)? }

WhileExpr { WhilePrefix Expr (!else Else Payload? Expr)? }

TypeExpr { //seq(repeat($.prefix_type_op), choice($.error_union_expr, $._suffix_expr)),
           suffixExpr }

suffixExpr { ( //seq("async", $._primary_type_expr, repeat($._suffix_op), $.fn_call_arguments),
               //seq($._primary_type_expr, repeat(choice($._suffix_op, $.fn_call_arguments))),
               !assign primaryTypeExpr (SuffixOp | FnCallArgs)* ) }

primaryTypeExpr {
  BuiltinIdentifier FnCallArgs
  | CharLiteral
  | ContainerDecl
  | "." Identifier
  | "." InitList
  | Float
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | Identifier
  | Integer
  | Anyframe
  | Unreachable
  | StringLiteral
  | SwitchExpr }

ContainerDecl { ( Extern | Packed )? ContainerDeclAuto }

GroupedExpr { "(" Expr ")" }

LabeledTypeExpr { BlockLabel Block | BlockLabel? LoopTypeExpr }

LoopTypeExpr { /*Inline?*/ ( ForTypeExpr | WhileTypeExpr) }

ForTypeExpr { ForPrefix TypeExpr (!else Else TypeExpr)? }

WhileTypeExpr { WhilePrefix TypeExpr (!else Else Payload? TypeExpr)? }

SwitchExpr { Switch "(" Expr ")" "{" (SwitchProng ",")* SwitchProng? "}" }

//// Helper grammar.

BreakLabel { !colonLabel ":" Identifier }

BlockLabel { /*left*/ Identifier !colonLabel ":" }

FieldInit { "." Identifier "=" Expr }

WhileContinueExpr { ":" "(" (AssignExpr | Expr) ")" }

//// Fn specific.

ParamDeclList { (ParamDecl ",")* ParamDecl? }

ParamDecl { //seq(optional($.doc_comment), optional(choice("noalias", "comptime")), optional(seq($.identifier, ":")), $.param_type),
            (Identifier ":") ParamType
            | "..." }

ParamType { Anytype | TypeExpr }

//// Control flow prefixes

IfPrefix { If "(" Expr ")" PtrPayload? }

WhilePrefix { While "(" Expr ")" PtrPayload? WhileContinueExpr? }

ForPrefix { For "(" ForArgList ")" PtrListPayload }

//// Payloads

Payload { "|" Identifier "|" }

PtrPayload { "|" Star? Identifier "|" }

PtrIndexPayload { "|" "*"? Identifier ("," Identifier) "|" }

PtrListPayload { "|" "*"? Identifier ("," "*"? Identifier)* ","? "|" }

Star { "*" }

//// Switch specific.

SwitchProng { /*Inline?*/ SwitchCase "=>" PtrIndexPayload? (AssignExpr | Expr) }

SwitchCase { SwitchItem ("," SwitchItem)* ","? | Else }

SwitchItem { Expr ("..." Expr)? }

//// For specific.

ForArgList { ForItem ("," ForItem)* ","? }

ForItem { Expr (".." Expr?)? }

//// Operators

CompareOp { "==" | "!=" | ">" | "<" | ">=" | "<=" }

AssignOp { "*=" | "*|=" | "/=" | "%=" | "+=" | "+|=" | "-=" | "-|=" | "<<=" | "<<|=" | ">>=" | "&=" | "^=" | "|=" | "*%=" | "+%=" | "-%=" | "=" }

BitwiseOp { "&" | "^" | "|" | Orelse | Catch Payload? }

BitShiftOp { "<<" | ">>" | "<<|" }

AdditionOp { "+" | "-" | "++" }

MultiplyOp { "||" | "*" | arithOp<"/"> | "%" | "**" | "*%" | "*|" }

PrefixOp { "!" | "-" | "~" | "-%" | "&" | Try | Await }

ArrayAccess { "[" Expr "]" }
Slice { "[" Expr ".." (Expr? (!colonSlice ":" Expr)?)? "]" }
Deref { ".*" }
Unwrap { ".?" }
FieldAccess { "." Identifier }

SuffixOp { Slice | ArrayAccess | FieldAccess | Deref | Unwrap }

FnCallArgs { !fncallargs "(" (Expr ",")* Expr? ")" }

//// ContainerDecl specific

ContainerDeclAuto { ContainerDeclType "{" ContainerDocComment? containerMembers "}" }

ContainerDeclType {
  Struct ("(" Expr ")")?
  | Opaque
  | Enum ("(" Expr ")")?
  | Union ("(" (Enum ("(" Expr ")")? | Expr) ")")? }

//// Alignment

ByteAlign { align "(" Expr ")" }

////

Identifier { identifier }

BuiltinIdentifier { builtinIdentifier }

StringLiteral { stringLiteralSingle | multiStringLiteral }

@skip { whitespace | LineComment }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\r"? "\n")+
  }

  align { "align" }
  And { "and" }
  Anyframe { "anyframe" }
  Anytype { "anytype" }
  Await { "await" }
  Break { "break" }
  Catch { "catch" }
  Comptime { "comptime" }
  Const { "const" }
  Continue { "continue" }
  Else { "else" }
  Enum { "enum" }
  Extern { "extern" }
  fn { "fn" }
  For { "for" }
  If { "if" }
  Opaque { "opaque" }
  Or { "or" }
  Orelse { "orelse" }
  Packed { "packed" }
  Pub { "pub" }
  Return { "return" }
  Switch { "switch" }
  Struct { "struct" }
  Test { "test" }
  Try { "try" }
  Union { "union" }
  Unreachable { "unreachable" }
  Var { "var" }
  While { "while" }

  //identifier: ($) => choice(/[A-Za-z_][A-Za-z0-9_]*/, seq("@", $.string_literal)),
  identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
  }

  builtinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  @precedence { align And Anyframe Anytype Await Break Catch Comptime Const Continue Else Enum Extern
                fn For If Opaque Or Orelse Packed Pub Return Struct Switch Test Try Union Unreachable Var While
                identifier }

  Integer {
    "0b" $[01] ("_"? $[01])*
    | "0o" $[0-7] ("_"? $[0-7])*
    | "0x" $[0-9a-fA-F] ("_"? $[0-9a-fA-F])*
    | $[0-9] ("_"? $[0-9])*
  }

  numeric_<regex> { regex ("_"? regex)* }

  Float {
    "0x" numeric_<$[0-9a-fA-F]> "." numeric_<$[0-9a-fA-F]> ($[pP] $[+\-]? numeric_<$[0-9]>)?
    | numeric_<$[0-9]> "." numeric_<$[0-9]> ($[eE] $[+\-]? numeric_<$[0-9]>)?
    | "0x" numeric_<$[0-9a-fA-F]> $[pP] "-" numeric_<$[0-9]>
    | numeric_<$[0-9]> $[eE] "-" numeric_<$[0-9]>
  }

  @precedence { Float Integer }

  multiStringLiteral { ("\\\\" ![\n]* $[ \n]*)+ }

  stringEscape { ("\\n" | "\\r" | "\\t" | "\\\\" | "\\'" | "\\\"" | "\\x" $[0-9a-fA-F] $[0-9a-fA-F]
                  | "\\u{" $[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] ($[0-9a-fA-F] $[0-9a-fA-F]?)?)?)?)? "}") }

  CharLiteral {
    "'"
    ( // charFragment
      !['\\]
      | stringEscape
    )*
    "'" }

  stringLiteralSingle {
    "\""
    ( // stringFragment
      !["\\]*
      | stringEscape
    )*
    "\"" }

  LineComment[isolate] { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  DocComment[isolate] { ("///" (![/\n] ![\n]* $[ \n]*|()))+ }

  containerComment { "//!" ![\n]* $[ \n]* }

  arithOp<expr> { expr }

  @precedence { containerComment, DocComment, LineComment, arithOp }
}

@external propSource highlighting from "./highlight"
