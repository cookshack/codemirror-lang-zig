@top Program { topLevelItem* }

topLevelItem { Decl }

//// Top level.

Decl { ( FnProto (";" | Block) | VarDecl ) }

FnProto { fn Identifier? "(" ParamDeclList ")" }

VarDecl { ( Const | Var ) Name (":" TypeExpr)?  ";" }

Name { identifier }

//// Block level.

Statement {
  Expr ";"
}

//// Expression level.

Expr { PrimaryExpr }

PrimaryExpr { Return }

Block { "{" Statement* "}" }

TypeExpr { //seq(repeat($.prefix_type_op), choice($.error_union_expr, $._suffix_expr)),
           suffixExpr }

suffixExpr { ( //seq("async", $._primary_type_expr, repeat($._suffix_op), $.fn_call_arguments),
               //seq($._primary_type_expr, repeat(choice($._suffix_op, $.fn_call_arguments))),
               PrimaryTypeExpr ) }

PrimaryTypeExpr { Identifier }

//// Fn specific

ParamDeclList { (ParamDecl ",")* ParamDecl? }

ParamDecl { //seq(optional($.doc_comment), optional(choice("noalias", "comptime")), optional(seq($.identifier, ":")), $.param_type),
            (Identifier ":") ParamType
            | "..." }

ParamType { anytype | TypeExpr }

Identifier { identifier }

@skip { whitespace | LineComment | BlockComment }

@tokens {
  whitespace {
    ($[ \t\r\n] | "\\" "\r"? "\n")+
  }

  anytype { "anytype" }
  Const { "const" }
  fn { "fn" }
  Return { "return" }
  Var { "var" }

  //identifier: ($) => choice(/[A-Za-z_][A-Za-z0-9_]*/, seq("@", $.string_literal)),
  identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
  }

  @precedence { anytype Const fn Return Var identifier }

  LineComment[isolate] { "//" ("\\" (![\n] | "\\r"? "\\n") | ![\n])* }

  BlockComment[isolate] { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  @precedence { LineComment, BlockComment }
}
